package com.twitter.producer.service.helper;import java.io.IOException;import java.net.HttpURLConnection;import java.net.Proxy;import java.net.URL;import java.net.URLConnection;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.HashSet;import java.util.Hashtable;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Set;import java.util.StringJoiner;import java.util.StringTokenizer;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.apache.commons.lang3.StringUtils;import org.springframework.social.twitter.api.HashTagEntity;import org.springframework.social.twitter.api.Tweet;import org.springframework.social.twitter.api.UrlEntity;public class TwitterStringsUtils {    private static final Pattern TWITTER_HASHTAG_PATTERN = Pattern.compile("#\\w+");       public static Set<String> tweetToHashTags(String text) {        Set<String> hashTags = new HashSet<>();        Matcher matcher = TWITTER_HASHTAG_PATTERN.matcher(text);        while (matcher.find()) {            String handle = matcher.group();            // removing '#' prefix            hashTags.add(handle.substring(1));        }        return hashTags;    }            public boolean removePunc = false;	public boolean negations = false;	public boolean removeStopWords = false;	private Hashtable<String, Integer> negators = new Hashtable<String, Integer>();	private Hashtable<String, String> negationMap = new Hashtable<String, String>();	private Hashtable<String, String> puncMap = new Hashtable<String, String>();	private Hashtable<String, Integer> puncs = new Hashtable<String, Integer>();		private final List<String> hashtags = new ArrayList<String>();	private final List<String> urlHash = new ArrayList<String>();		private final List<String> userMentions = new ArrayList<String>();	private final List<String> userRetweet = new ArrayList<String>();			private static final Pattern urlPattern = Pattern.compile(		        "(?:^|[\\W])((ht|f)tp(s?):\\/\\/|www\\.)"		                + "(([\\w\\-]+\\.){1,}?([\\w\\-.~]+\\/?)*"		                + "[\\p{Alnum}.,%_=?&#\\-+()\\[\\]\\*$~@!:/{};']*)",		        Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);		private final static String URL_REGEX = "((www\\.[\\s]+)|(https?://[^\\s]+))"; 		private final List<String> tweetURLS = new ArrayList<String>();	public TwitterStringsUtils(boolean puncs, boolean negs, boolean stopW){		buildNegationMap();		buildPuncMap();		removePunc = puncs;		negations = negs;		removeStopWords = stopW;	}		private void buildNegationMap(){		String doNot = "donot";		negationMap.put("don't", doNot);		negationMap.put("do not", doNot);		negationMap.put("dont", doNot);		negators.put(doNot, 1);				String doesNot = "doesnot";		negationMap.put("doesn't", doesNot);		negationMap.put("does not", doesNot);		negationMap.put("doesnt", doesNot);		negators.put(doesNot, 1);				String didNot = "didnot";		negationMap.put("didn't", didNot);		negationMap.put("did not", didNot);		negationMap.put("didnt", didNot);		negators.put(didNot, 1);				String amNot = "amnot";		negationMap.put("am not", amNot);		negationMap.put("amn't", amNot);		negationMap.put("amnt", amNot);		negators.put(amNot, 1);				String isNot = "isnot";		negationMap.put("is not", isNot);		negationMap.put("isn't", isNot);		negationMap.put("isnt", isNot);		negators.put(isNot, 1);				String areNot = "arenot";		negationMap.put("are not", areNot);		negationMap.put("aren't", areNot);		negationMap.put("arent", areNot);		negators.put(areNot, 1);				String wasNot = "wasnot";		negationMap.put("was not", wasNot);		negationMap.put("wasn't", wasNot);		negationMap.put("wasnt", wasNot);		negators.put(wasNot, 1);				String wereNot = "werenot";		negationMap.put("were not", wereNot);		negationMap.put("weren't", wereNot);		negationMap.put("werent", wereNot);		negators.put(wereNot, 1);				String hasNot = "hasnot";		negationMap.put("has not", hasNot);		negationMap.put("hasn't", hasNot);		negationMap.put("hasnt", hasNot);		negators.put(hasNot, 1);				String haveNot = "havenot";		negationMap.put("have not", haveNot);		negationMap.put("haven't", haveNot);		negationMap.put("havent", haveNot);		negators.put(haveNot, 1);				String hadNot = "hadnot";		negationMap.put("had not", hadNot);		negationMap.put("hadn't", hadNot);		negationMap.put("hadnt", hadNot);		negators.put(hadNot, 1);				String willNot = "willnot";		negationMap.put("will not", willNot);		negationMap.put("willn't", willNot);		negationMap.put("willnt", willNot);		negators.put(willNot, 1);				String wouldNot = "wouldnot";		negationMap.put("would not", wouldNot);		negationMap.put("wouldn't", wouldNot);		negationMap.put("wouldnt", wouldNot);		negators.put(wouldNot, 1);				String canNot = "cannot";		negationMap.put("can not", canNot);		negationMap.put("cann't", canNot);		negationMap.put("cannt", canNot);		negators.put(canNot, 1);				String shouldNot = "shouldnot";		negationMap.put("should not", shouldNot);		negationMap.put("shouldn't", shouldNot);		negationMap.put("shouldnt", shouldNot);		negators.put(shouldNot, 1);				String couldNot = "couldnot";		negationMap.put("could not", couldNot);		negationMap.put("couldn't", couldNot);		negationMap.put("couldnt", couldNot);		negators.put(couldNot, 1);				String never = "never";		negators.put(never, 1);		String not = "not";		negators.put(not, 1);		String nothing = "nothing";		negators.put(nothing, 1);	}		private void buildPuncMap(){		puncMap.put("\\.", " . ");		puncMap.put("\\,", " , ");		puncMap.put("\\;", " ; ");		puncMap.put("\\?", " ? ");		puncMap.put("\\!", " ! ");		puncs.put(".", 1);		puncs.put(",", 1);		puncs.put(";", 1);		puncs.put("?", 1);		puncs.put("!", 1);	}		public boolean isValidTweet(String tweetDate_){		boolean result = false;		if(tweetDate_.matches("^\\d{4}-\\d{2}-\\d{2}\\s{1}\\d{2}:\\d{2}:\\d{2}")){			result = true;		}				return result;	}		public String cleanTweet(String rawTweet){		//remove web link	   // String cleanTweet = rawTweet.replaceAll("\\s*http://\\S+\\s*", " ");		//private final static String URL_REGEX = "((www\\.[\\s]+)|(https?://[^\\s]+))"; 			    String cleanTweet = rawTweet.replaceAll(URL_REGEX, " ");	    //remove @Somebody	    cleanTweet = cleanTweet.replaceAll("@\\S+", "");	    //remove RT	    cleanTweet = cleanTweet.replaceAll("RT", "");	    //remove hashcode	    cleanTweet = cleanTweet.replaceAll("#", "");	    cleanTweet = cleanTweet.replaceAll("^", "");	  	    //remove numbers	    cleanTweet = cleanTweet.replaceAll("\\d+", " ");	    cleanTweet = cleanTweet.toLowerCase();	    if(negations){	    	cleanTweet = convertNegations(cleanTweet);	    }	  	    if(negations){	    	cleanTweet = extractNegations(cleanTweet);	    }		if(removePunc){			cleanTweet = removePuncs(cleanTweet);		}	    	    		return cleanTweet;	}		public String removePuncs(String text){	    //remove punctuations		text = text.replaceAll("\\p{Punct}", " ");	    return text;	}		public String convertNegations(String text){		//clean up negations		for(Map.Entry<String, String> entry : negationMap.entrySet()){			text = text.replaceAll(entry.getKey(), entry.getValue());		}		//clean up punctuations		for(Map.Entry<String, String> entry : puncMap.entrySet()){			text = text.replaceAll(entry.getKey(), entry.getValue());		}				return text;	}					public String extractNegations(String text){						String [] words = text.split(" ");		int state = 0;		String newText = new String("");		boolean begin = true;		for(String word : words){			//System.out.println(word);						if(puncs.containsKey(word)){				newText += " " + word;			}			else if(state == 1){				newText += " " + "not" + word;			}else if(state == 0 && begin){				newText += word;				begin = false;			}else if(state == 0 && !puncs.containsKey(word)){				newText += " " + word;			}						if(negators.containsKey(word) && state == 0){				//entered negation state				state = 1;				//System.out.println("entered neg state!");			}			else if(puncs.containsKey(word) && state == 1){				//exiting negation state				state = 0;				//System.out.println("exiting neg state!!");			}		}				return newText;	}		 public List<String> parseTweetforHasTags(String tweetText) {	        StringTokenizer tokenizer = new StringTokenizer(tweetText);	        while (tokenizer.hasMoreTokens()) {	            String token = tokenizer.nextToken();	            if (token.startsWith("#")) {	                hashtags.add(token);	            }	        }	        return hashtags;	    }	 	 	 public List<String> parseTweetforUSerMentions(String tweetText) {	        StringTokenizer tokenizer = new StringTokenizer(tweetText);	        while (tokenizer.hasMoreTokens()) {	            String token = tokenizer.nextToken();	            if (token.startsWith("@") && !token.endsWith(":")) {	            	userMentions.add(token);	            }	        }	        	        return userMentions;	    }	 	 public static List<String> getUSerMentions(String tweetText) {	        StringTokenizer tokenizer = new StringTokenizer(tweetText);	        List<String> userMentions = new ArrayList<String>();	        while (tokenizer.hasMoreTokens()) {	            String token = tokenizer.nextToken();	            if (token.startsWith("@") && !token.endsWith(":")) {	            	userMentions.add(token);	            }	        }	        	        return userMentions;	    }	 	 public List<String> parseTweetforRetweets(String tweetText) {	        StringTokenizer tokenizer = new StringTokenizer(tweetText);	        while (tokenizer.hasMoreTokens()) {	            String token = tokenizer.nextToken();	            if (token.startsWith("@") && token.endsWith(":")) {	            	userRetweet.add(token);	            }	        }	        	        return userRetweet;	    }	 	 public List<String> parseTweetforURLS(String tweetText) {		 		 Matcher matcher = urlPattern.matcher(tweetText);		 		 while (matcher.find()) {			    int matchStart = matcher.start(1);			    int matchEnd = matcher.end();			    String strURL = tweetText.substring(matchStart, matchEnd);			    tweetURLS.add(strURL)	;				 			    			}		 return tweetURLS;	 }	 		 public Set<String> getUniqueHashtags() {	        Set<String> unique = new HashSet<String>();	        unique.addAll(hashtags);	        return unique;	    }			 public  String expandUrl(String shortenedUrl) throws IOException {	      		 URL url = null;			 if (shortenedUrl!=null && shortenedUrl.indexOf("http")>=0) 			// System.out.println("Enter : " + shortenedUrl);			 url = new URL(shortenedUrl); 				        // open connection	        HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY); 	        // stop following browser redirect	        httpURLConnection.setInstanceFollowRedirects(false);	         	        // extract location header containing the actual destination URL	        String expandedURL = httpURLConnection.getHeaderField("Location");	        httpURLConnection.disconnect();	        	     //   System.out.println("Exit : " + expandedURL);	        	        return expandedURL;	    }	 	 public String removeUrl(String commentstr)	    {		 		// \\}\\),\\(\\{			 		 	commentstr = StringUtils.replace(commentstr,  ")", "") ;		 	commentstr = StringUtils.replace(commentstr,  "(", "") ;		 	commentstr = StringUtils.replace(commentstr,  "\\", "") ;		 	commentstr = StringUtils.replace(commentstr,  "?", "") ;		 	commentstr = StringUtils.replace(commentstr,  "+", "") ;						   		   	        String urlPattern = "((https?|ftp|gopher|telnet|file|Unsure|http):((//)|(\\\\))+[\\w\\d:#@%/;$()~_?\\+-=\\\\\\.&]*)";	        Pattern p = Pattern.compile(urlPattern,Pattern.CASE_INSENSITIVE);	        Matcher m = p.matcher(commentstr);	        int i = 0;	        while (m.find()) {	            commentstr = commentstr.replaceAll(m.group(i),"").trim();	            i++;	        }	        return commentstr;	    }	 		public String getTopicExpandedURL(Tweet tweet) {			String topicURL =null;            List<UrlEntity> urlEntities = tweet.getEntities().getUrls();            if(urlEntities!=null )            	topicURL = urlEntities.get(0).getExpandedUrl(); 			return topicURL;		}				public String getTopicTags(Tweet topic) {			StringJoiner hashTagsCombined = new StringJoiner("|");	        List<HashTagEntity>  hashTagEntities = topic.getEntities().getHashTags();	        if(hashTagEntities!=null)hashTagEntities.forEach(h->hashTagsCombined.add(h.getText()));			return hashTagsCombined.toString();		}						public String transformTopic(String tweetText) {			String rawTweet;			rawTweet = tweetText.replaceAll("@\\S+", "");			rawTweet = rawTweet.replaceAll("\\n", "");			rawTweet = rawTweet.replaceAll("\\r", "");			//remove RT			rawTweet = rawTweet.replaceAll("RT", "");			rawTweet = rawTweet.replaceAll(" Re:", "");						//Remove URL			rawTweet = removeUrl(rawTweet);			return rawTweet;		}	 	 	 public static void main(String ar[]) throws Exception{		 		 		 		 String url = "https://www.gartner.com/reviews/market/cloud-web-application-and-api-protection/vendor/sucuri/product/sucuri-website-firewall-waf";		 		 		 String[] urlPathParams = url.split("\\/");		 		 System.out.println(urlPathParams[0] + "\n" + urlPathParams[0] + "\\n"+ urlPathParams[2] + "\n" + urlPathParams[3] 				 + "\n"+ urlPathParams[4] + "\n" + urlPathParams[5] + "\n"+ urlPathParams[6] + "\n" + urlPathParams[7] );		 		 System.exit(1);		 		 		 TwitterStringsUtils util = new TwitterStringsUtils(true, true, true);		 		 String strTweet =  "| DevOpsSummithttps://t.co/j4zsxNAnHo ";		 		 String cleanTweet = util.removeUrl(strTweet);		 //String cleanTweet = util.cleanTweet(strTweet);		 		 		 System.out.println(cleanTweet);		 		 System.exit(1);		 		 String cretaedAt = "Sat Sep 17 12:59:37 +0000 2016";		 		 SimpleDateFormat sdf = new SimpleDateFormat("EE MMM dd HH:mm:ss z yyyy",	                Locale.ENGLISH);		 Date parsedDate = sdf.parse( cretaedAt);		 		 System.out.println(new SimpleDateFormat("ddMMyyyy").format(parsedDate));	    	SimpleDateFormat userCreatedDate = new SimpleDateFormat("dd-MM-yyyy");		    userCreatedDate.toString();					 //https://t.co/yvAD1fc8MQ		 //http://fb.me/1jVG9iFgp		 	 }	            }